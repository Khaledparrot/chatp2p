<!DOCTYPE html><html>
<head>
  <title>P2P Voice Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; }
    body, html {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: #f0f0f0;
      height: 100%;
    }
    .screen { display: none; padding: 16px; height: 100%; }
    .active { display: block; }
    #chatBox {
      height: 70vh;
      overflow-y: auto;
      background: #eaeaea;
      padding: 10px;
      display: flex;
      flex-direction: column;
    }
    .bubble {
      max-width: 80%;
      padding: 10px;
      margin: 6px;
      border-radius: 10px;
      word-wrap: break-word;
    }
    .you { align-self: flex-end; background: #cce5ff; }
    .peer { align-self: flex-start; background: #d4edda; }
    #msgBar { display: flex; gap: 8px; margin-top: 10px; }
    textarea { flex: 1; padding: 10px; font-size: 16px; border-radius: 8px; }
    button { padding: 10px; font-size: 16px; border-radius: 8px; }
  </style>
</head>
<body><div id="login" class="screen active">
  <h2>Enter Username</h2>
  <input id="usernameInput" placeholder="Your name" />
  <button onclick="saveUsername()">Continue</button>
</div><div id="chat" class="screen">
  <h3>Welcome, <span id="myName"></span></h3>
  <div id="chatBox"></div>
  <div id="msgBar">
    <textarea id="msg" rows="2" placeholder="Type..."></textarea>
    <button onclick="sendMessage()">Send</button>
  </div>
  <div>
    <label>Voice Filter:
      <select id="voiceFilter">
        <option value="normal">Normal</option>
        <option value="pitchUp">Pitch Up</option>
        <option value="pitchDown">Pitch Down</option>
        <option value="robot">Robot</option>
      </select>
    </label>
    <button onclick="startRecording()">üéôÔ∏è Record Voice</button>
  </div>
</div><script>
let username = localStorage.getItem("username");
const chatBox = document.getElementById("chatBox");
let pc, channel;

if (username) {
  document.getElementById("myName").textContent = username;
  switchScreen("chat");
  setupConnection();
}

function saveUsername() {
  username = document.getElementById("usernameInput").value.trim();
  if (!username) return alert("Please enter a name");
  localStorage.setItem("username", username);
  document.getElementById("myName").textContent = username;
  switchScreen("chat");
  setupConnection();
}

function switchScreen(id) {
  document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
  document.getElementById(id).classList.add("active");
}

function appendMessage(text, from) {
  const div = document.createElement("div");
  div.className = `bubble ${from === username ? 'you' : 'peer'}`;
  div.innerHTML = `<strong>${from}:</strong><br>${text}`;
  chatBox.appendChild(div);
  chatBox.scrollTop = chatBox.scrollHeight;
}

function appendAudio(blob, from) {
  const div = document.createElement("div");
  div.className = `bubble ${from === username ? 'you' : 'peer'}`;
  const audio = document.createElement("audio");
  audio.controls = true;
  audio.src = URL.createObjectURL(blob);
  div.innerHTML = `<strong>${from}:</strong><br>`;
  div.appendChild(audio);
  chatBox.appendChild(div);
  chatBox.scrollTop = chatBox.scrollHeight;
}

function sendMessage() {
  const msg = document.getElementById("msg").value;
  if (msg && channel && channel.readyState === "open") {
    const data = JSON.stringify({ type: 'text', from: username, msg });
    channel.send(data);
    appendMessage(msg, username);
    document.getElementById("msg").value = "";
  }
}

async function startRecording() {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const filter = document.getElementById("voiceFilter").value;

  const audioCtx = new AudioContext();
  const source = audioCtx.createMediaStreamSource(stream);
  let processor = audioCtx.createScriptProcessor(2048, 1, 1);
  const dest = audioCtx.createMediaStreamDestination();

  // Pitch/robot filters placeholder (actual effects can be added with WebAudio)
  source.connect(dest); // Replace with filter chains

  const mediaRecorder = new MediaRecorder(dest.stream);
  let chunks = [];

  mediaRecorder.ondataavailable = e => chunks.push(e.data);
  mediaRecorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'audio/webm' });
    channel.send(blob);
    appendAudio(blob, username);
  };
  mediaRecorder.start();

  setTimeout(() => mediaRecorder.stop(), 3000); // auto stop after 3s
}

function setupConnection() {
  pc = new RTCPeerConnection();
  channel = pc.createDataChannel("chat");
  channel.onmessage = e => {
    if (typeof e.data === "string") {
      const obj = JSON.parse(e.data);
      appendMessage(obj.msg, obj.from);
    } else {
      const blob = new Blob([e.data], { type: 'audio/webm' });
      appendAudio(blob, "Peer");
    }
  };
  channel.onopen = () => appendMessage("‚úÖ Connected", "System");
  // Add ICE signaling logic here or manual input steps if no server
}
</script></body>
</html>
